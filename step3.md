<h1> 코드에서 나는 악취!! </h1>

<h2> 이름 짓기 </h2>
코드를 명료하게 표현하는 데 가장 중요한 요소중 하나는 바로 "이름" 이다.
그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용하는지 명확히 알 수 있도록 해야 한다.

만약 마땅히 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 매우 높다.

<h2> 중복 코드 </h2>
똑같은 코드 구조가 여러곳에서 반복 된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

단, 중복되는 코드를 볼 때 서로 차이점이 없는지 유심히 살펴봐야 한다.

1. 두 메서드가 동일한 표현식을 사용한다면 (함수 추출)하기 사용하기.
2. 비슷한데 완전히 같지 않다면 (문장 슬라이드) 하기.
3. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면 (메서드 올리기)를 사용하기.

<h2> 긴 함수 </h2>
간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 된다.

코드에서 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.

즉, 함수이름에는 "목적"이 드러나야 한다. '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.

<h2> 긴 매개변수 목록 </h2>
매개 변수를 많이 받는 함수가 있을 수 있다.

이럴 때에는 다음과 같은 방법을 사용할 수 있다.
1. 매개변수를 질의 함수로 바꾸기
2. 객체 통째로 넘기기
3. 매개변수 객체 만들기
4. 플래그 인수 제거하기

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.

<h1> 전역 데이터 </h1>
전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿧는지 찾아낼 메커니즘이 없다는 게 문제다.

이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 변수 캡슐화하기다.

함수들을 클래스나 모듈에 집어넣고 그 안에섬나 사용할 수 있도록 접근 범위를 최소로 줄이는 것이 좋다.

<h2> 가변 데이터 </h2>
데이터를 변경했더니 예상치 못한 결과나 골치 앞느 버그로 이어지는 경우가 종종 있다.
이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 
데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고있다.(reduce, assign 등...)

가변 데이터를 처리하는 방법은 여러가지가 있다.
1. 변수 캡슐화 하기 : 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 감시하기.
2. 변수 쪼개기 : 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
3. 문장 슬라이드하기와 함수 추출하기 : 값을 갱신하는 코드는 다른 코드들로부터 떨어뜨려 놓는 것이 좋다.
4. 질의 함수와 변경 함수 분리하기 : API를 만들 때 꼭 필요한 경우가 아니라면 부작용 있는 코드를 호출할 수 없게 막는다.
5. 세터 제거하기
6. 여러 함수를 클래스나 변환 함수로 묶기 : 변수를 갱신하는 코드들의 유효범위를 클래스나 변환으로 제안한다.
7. 참조를 값으로 바꾸기 : 내부 필드에 데이터를 담고 있는 변수를 수정하려면, 구조체를 새로 만드는 것이 좋다.

<h2> 뒤엉킨 변경 </h2>
뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.

예컨대 지원해야 할 데이터 베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈 등이다.

이럴때는 단계 쪼개기, 함수 옮기기, 함수 추출하기, 클래스 추출하기 등을 사용한다.

<h2> 산탄총 수술 </h2>
산탄총 수술은 코드를 변경할 대마다 자잘하게 수정해야 하는 클래스가 많을 때를 가르킨다.

이럴때는 함수 옮기기와 필드 옮기기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기, 단계 쪼개기를 적용한다.

<h2> 기능 편애 </h2>
기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.

프로그램을 모듈화할 때는 코드를 여러 영역을 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다.

이를 해결하는 좋은 디자인 패턴은 전략 패턴, 방문자 패턴이 있다.

즉, 모듈 단계에서 서로의 연결 끈이 두터운 것을 말한다. 이는 리팩토링을 통해서 구분하거나 설계를 다시해야 한다.

<h2> 데이터 뭉치 </h2>
데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.

이럴때는 클래스 추출하기, 매개변수 객체 만들기, 객체 통째로 넘기기를 활용한다.

데이터 뭉치인지 판별하는 방법은 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 데이터 뭉치라는 뜻이다.

<h2> 기본형 집착 </h2>
음... 금액을 그냥 숫자로 계산하거나, 물리량을 계산할 때 밀리미터나 인치 같은 단위를 무시하는 행위

<h2> switch문 </h2>
사용하지 말거라~~

<h2> 반복문 </h2>
반복문은 반복문을 파이프라인으로 바뀌기를 적용시킨다.

<h2> 성의 없는 요소 </h2>
코드를 만들다보면 필요 없는 코드가 생기기 마련이다. 이럴때는 고이 보내주자~

<h2> 추측성 일반화 </h2>
"이런 코드는 언젠가 필요할꺼야!!" 라는 전재로 만들어진 추축성 코드.
이런 코드는 미리 만들어 버리면 햇갈리고 지저분해 지므로 치워버리자.

<h2> 임시 필드 </h2>
간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 이런 경우도 문제가 될 여지가 있으므로,

클래스 추출하기, 함수 옮기기, 특이 케이스 추가하기로 정리하자.

<h2> 메시지 체인 </h2>
메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 

다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

이는 객체가 구조에 종속됐음을 의미한다. 

<h2> 중개자 </h2>
미들 맨.

<h2> 거대한 클래스 </h2>
한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그래고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

이럴 때는 클래스 추출하기로 필드들 일부를 따로 묶는다.

좋은 해결 방법은 클래스에 필드가 많아지면 클래스 내부에서 중복 코드를 지우고 메서드를 통합하는 과정이 좋다.

또 유능한 기능 그룹을 찾았다면 클래스 추출하기, 슈퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기 등을 활용하여 클래스로 분리한다.

<h2> 데이터 클래스 </h2>
게터/세터 메소드로만 구성된 클래스를 말한다. 이런 클래스에 public 필드가 있다면 얼른 레코드 캡슐화하기로 숨기자!!

불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

<h2> 상속 포기 </h2>
자식 클래스는 부모 클래스로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나,필요 없는 경우도 있다.

이럴때는 수많은 유산 중에서 관심 있는 몇 개만 받고 끝내려는 경우가 얼마든지 있다.

이를 해결하기 위해서는 부모 클래스에 공통된 부분만 남기고 모두 서브 클래스로 넘겨버리자.

부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람들도 있지만, 우리는 이런 방식을 권하지 않는다.

<h2> 주석 </h2>
주석은 악취가 아니라 향기 난다~~

하지만 주석이 많으면 악취가 나는 코드가 나오기 쉽다. 주석이 있다면 해당 주석이 설명하는 기능을 따로 만들어보자.


